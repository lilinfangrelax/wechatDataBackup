// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.33.0 // protoc-gen-go 工具的版本号
// 	protoc        v3.6.1 // protoc 编译器的版本号
// source: msg.proto // 原始的 Protocol Buffer 定义文件
/**
这段代码是一个Go语言文件，属于`wechat`包，主要用于定义和处理Protocol Buffer（protobuf）消息。以下是对代码的详细解释：

1. **包声明和导入**：
   - `package wechat`：声明了包名为`wechat`。
   - 导入的包：
     - `google.golang.org/protobuf/reflect/protoreflect`：用于反射Protocol Buffer消息。
     - `google.golang.org/protobuf/runtime/protoimpl`：提供Protocol Buffer运行时的实现细节。
     - `reflect`：Go语言的反射机制包。
     - `sync`：提供基本的同步原语（如互斥锁等）。

2. **版本验证常量**：
   - `protoimpl.EnforceVersion(20 - protoimpl.MinVersion)`：验证生成的代码是否足够新（兼容最小版本）。
   - `protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)`：验证运行时是否足够新（兼容最大版本）。

3. **消息结构体**：
   - `SubMessage1`是一个Protocol Buffer消息结构体，包含以下字段：
     - `state`：由protobuf运行时维护的消息状态信息。
     - `sizeCache`：消息的编码大小缓存。
     - `unknownFields`：用于兼容性的未知字段。
     - `Field1`和`Field2`：两个整型字段，标签分别为1和2，使用proto3语法，JSON编码时如果为空则忽略。

4. **方法**：
   - `Reset()`：将`SubMessage1`结构体重置为零值。如果启用了`UnsafeEnabled`，还会更新消息状态和类型信息。
   - `String()`（未完全展示）：返回`SubMessage1`的字符串表示形式（通常用于调试或日志记录）。

这段代码是典型的Protocol Buffer生成的Go代码，用于序列化和反序列化结构化数据，通常用于网络通信或数据存储。



这段 Go 语言代码片段位于由 `protoc-gen-go` 工具自动生成的 [`pkg\wechat\msg.pb.go`](pkg/wechat/msg.pb.go) 文件中，其主要目的是进行版本兼容性检查。

以下是详细解释：

1.  **目的和功能**
    *   **目的**: 这行代码旨在验证当前 Go 环境中使用的 `google.golang.org/protobuf/runtime/protoimpl` 包（Protocol Buffer 的 Go 运行时实现）的版本是否与生成此代码的 `protoc-gen-go` 工具兼容。
    *   **功能**: [`protoimpl.EnforceVersion()`](google.golang.org/protobuf/runtime/protoimpl/protoimpl.go) 函数会执行一个内部检查。如果 `protoimpl` 运行时的版本与期望的版本范围不符，它可能会导致程序崩溃或发出警告，从而确保生成的代码在兼容的环境中运行，避免因版本不匹配而导致的潜在问题。

2.  **关键组件及其交互**
    *   [`protoimpl.EnforceVersion()`](google.golang.org/protobuf/runtime/protoimpl/protoimpl.go): 这是 `google.golang.org/protobuf/runtime/protoimpl` 包提供的一个函数，用于执行版本检查。它接收一个整数参数，该参数代表了期望的运行时版本与当前运行时版本之间的差异。
    *   [`protoimpl.MaxVersion`](google.golang.org/protobuf/runtime/protoimpl/protoimpl.go): 这是 `protoimpl` 包中的一个常量，表示该运行时库支持的最高版本号。
    *   `- 20`: 这是一个版本偏移量。表达式 `protoimpl.MaxVersion - 20` 定义了一个版本阈值。这意味着生成的代码要求 `protoimpl` 运行时的版本不能高于 `protoimpl.MaxVersion` 减去 20。这个偏移量通常用于提供一定的向后兼容性，允许生成的代码与稍旧的 `protoimpl` 运行时版本一起工作。
    *   `_ =`: 这是一个 Go 语言的空白标识符。它用于丢弃函数的返回值。在这里，[`protoimpl.EnforceVersion()`](google.golang.org/protobuf/runtime/protoimpl/protoimpl.go) 函数的返回值被明确忽略，因为我们只关心它执行版本检查的副作用（即如果版本不兼容，它可能会导致程序终止）。

3.  **重要的模式或技术**
    *   **代码生成 (Code Generation)**: 这段代码是自动生成的，这是 Protocol Buffers 的一个核心特性。通过 `.proto` 文件定义数据结构，然后使用 `protoc` 编译器和相应的插件（如 `protoc-gen-go`）自动生成各种编程语言的源代码。这种模式确保了数据结构在不同系统和语言之间的一致性。
    *   **版本兼容性检查 (Version Compatibility Check)**: 在自动生成的代码中包含版本检查是一种重要的防御性编程实践。它确保了代码所依赖的库（这里是 `protoimpl` 运行时）的版本在可接受的范围内。这有助于在开发和部署过程中及早发现并解决因库版本不匹配而引起的问题，提高软件的健壮性。
    *   **空白标识符 (`_`) 的使用**: 在 Go 语言中，当一个函数的返回值不需要被使用时，通常会将其赋值给空白标识符 `_`。这表明开发者有意忽略该返回值，并且代码的意图是利用函数的副作用（例如，这里的版本检查）。
**/
package wechat // 定义包名为 wechat

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect" // 导入 protoreflect 包，用于反射 Protocol Buffer 消息。
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"     // 导入 protoimpl 包，提供了 Protocol Buffer 运行时的实现细节。
	reflect "reflect"                                            // 导入 reflect 包，用于 Go 语言的反射机制。
	sync "sync"                                                  // 导入 sync 包，提供了基本的同步原语。
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	// 验证生成的代码是否足够新。
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	// 验证运行时/protoimpl 是否足够新。
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SubMessage1 是一个 Protocol Buffer 消息结构体。
type SubMessage1 struct {
	state         protoimpl.MessageState // 消息的状态信息，由 protobuf 运行时维护。
	sizeCache     protoimpl.SizeCache    // 消息的编码大小缓存。
	unknownFields protoimpl.UnknownFields // 未知字段，用于兼容性。

	Field1 int32 `protobuf:"varint,1,opt,name=field1,proto3" json:"field1,omitempty"` // 字段1，整型，标签为1，可选，proto3 语法，JSON 编码时如果为空则忽略。
	Field2 int32 `protobuf:"varint,2,opt,name=field2,proto3" json:"field2,omitempty"` // 字段2，整型，标签为2，可选，proto3 语法，JSON 编码时如果为空则忽略。
}

// Reset 方法重置 SubMessage1 结构体为零值。
func (x *SubMessage1) Reset() {
	*x = SubMessage1{} // 将结构体置为零值。
	if protoimpl.UnsafeEnabled {
		mi := &file_msg_proto_msgTypes[0] // 获取消息类型信息。
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) // 获取消息状态。
		ms.StoreMessageInfo(mi) // 存储消息信息。
	}
}

// String 方法返回 SubMessage1 结构体的字符串表示。
func (x *SubMessage1) String() string {
	return protoimpl.X.MessageStringOf(x) // 使用 protobuf 运行时的方法生成字符串。
}

// ProtoMessage 方法是一个标记接口，表示 SubMessage1 是一个 Protocol Buffer 消息。
func (*SubMessage1) ProtoMessage() {}

// ProtoReflect 方法返回 SubMessage1 结构体的 protoreflect.Message 接口，用于反射操作。
func (x *SubMessage1) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[0] // 获取消息类型信息。
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) // 获取消息状态。
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi) // 如果消息信息未加载，则加载。
		}
		return ms // 返回消息状态。
	}
	return mi.MessageOf(x) // 返回消息的反射表示。
}

// Deprecated: Use SubMessage1.ProtoReflect.Descriptor instead.
// Descriptor 方法返回 SubMessage1 结构体的 Protocol Buffer 描述符。
// 此方法已弃用，建议使用 ProtoReflect.Descriptor。
func (*SubMessage1) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{0} // 返回原始描述符和字段索引。
}

// GetField1 方法返回 SubMessage1 的 Field1 字段的值。
func (x *SubMessage1) GetField1() int32 {
	if x != nil {
		return x.Field1 // 如果结构体不为空，返回 Field1 的值。
	}
	return 0 // 否则返回默认值 0。
}

// GetField2 方法返回 SubMessage1 的 Field2 字段的值。
func (x *SubMessage1) GetField2() int32 {
	if x != nil {
		return x.Field2 // 如果结构体不为空，返回 Field2 的值。
	}
	return 0 // 否则返回默认值 0。
}

// SubMessage2 是另一个 Protocol Buffer 消息结构体。
type SubMessage2 struct {
	state         protoimpl.MessageState // 消息的状态信息。
	sizeCache     protoimpl.SizeCache    // 消息的编码大小缓存。
	unknownFields protoimpl.UnknownFields // 未知字段。

	Field1 int32  `protobuf:"varint,1,opt,name=field1,proto3" json:"field1,omitempty"` // 字段1，整型。
	Field2 string `protobuf:"bytes,2,opt,name=field2,proto3" json:"field2,omitempty"` // 字段2，字符串。
}

// Reset 方法重置 SubMessage2 结构体。
func (x *SubMessage2) Reset() {
	*x = SubMessage2{} // 将结构体置为零值。
	if protoimpl.UnsafeEnabled {
		mi := &file_msg_proto_msgTypes[1] // 获取消息类型信息。
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) // 获取消息状态。
		ms.StoreMessageInfo(mi) // 存储消息信息。
	}
}

// String 方法返回 SubMessage2 结构体的字符串表示。
func (x *SubMessage2) String() string {
	return protoimpl.X.MessageStringOf(x) // 使用 protobuf 运行时的方法生成字符串。
}

// ProtoMessage 方法是一个标记接口。
func (*SubMessage2) ProtoMessage() {}

// ProtoReflect 方法返回 SubMessage2 结构体的 protoreflect.Message 接口。
func (x *SubMessage2) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[1] // 获取消息类型信息。
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) // 获取消息状态。
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi) // 如果消息信息未加载，则加载。
		}
		return ms // 返回消息状态。
	}
	return mi.MessageOf(x) // 返回消息的反射表示。
}

// Deprecated: Use SubMessage2.ProtoReflect.Descriptor instead.
// Descriptor 方法返回 SubMessage2 结构体的 Protocol Buffer 描述符。
func (*SubMessage2) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{1} // 返回原始描述符和字段索引。
}

// GetField1 方法返回 SubMessage2 的 Field1 字段的值。
func (x *SubMessage2) GetField1() int32 {
	if x != nil {
		return x.Field1 // 如果结构体不为空，返回 Field1 的值。
	}
	return 0 // 否则返回默认值 0。
}

// GetField2 方法返回 SubMessage2 的 Field2 字段的值。
func (x *SubMessage2) GetField2() string {
	if x != nil {
		return x.Field2 // 如果结构体不为空，返回 Field2 的值。
	}
	return "" // 否则返回默认值空字符串。
}

// MessageBytesExtra 是一个 Protocol Buffer 消息结构体，包含两个子消息。
type MessageBytesExtra struct {
	state         protoimpl.MessageState // 消息的状态信息。
	sizeCache     protoimpl.SizeCache    // 消息的编码大小缓存。
	unknownFields protoimpl.UnknownFields // 未知字段。

	Message1 *SubMessage1   `protobuf:"bytes,1,opt,name=message1,proto3" json:"message1,omitempty"` // 消息1，类型为 SubMessage1，标签为1。
	Message2 []*SubMessage2 `protobuf:"bytes,3,rep,name=message2,proto3" json:"message2,omitempty"` // 消息2，类型为 SubMessage2 的切片，标签为3，表示重复字段。
}

// Reset 方法重置 MessageBytesExtra 结构体。
func (x *MessageBytesExtra) Reset() {
	*x = MessageBytesExtra{} // 将结构体置为零值。
	if protoimpl.UnsafeEnabled {
		mi := &file_msg_proto_msgTypes[2] // 获取消息类型信息。
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) // 获取消息状态。
		ms.StoreMessageInfo(mi) // 存储消息信息。
	}
}

// String 方法返回 MessageBytesExtra 结构体的字符串表示。
func (x *MessageBytesExtra) String() string {
	return protoimpl.X.MessageStringOf(x) // 使用 protobuf 运行时的方法生成字符串。
}

// ProtoMessage 方法是一个标记接口。
func (*MessageBytesExtra) ProtoMessage() {}

// ProtoReflect 方法返回 MessageBytesExtra 结构体的 protoreflect.Message 接口。
func (x *MessageBytesExtra) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[2] // 获取消息类型信息。
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) // 获取消息状态。
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi) // 如果消息信息未加载，则加载。
		}
		return ms // 返回消息状态。
	}
	return mi.MessageOf(x) // 返回消息的反射表示。
}

// Deprecated: Use MessageBytesExtra.ProtoReflect.Descriptor instead.
// Descriptor 方法返回 MessageBytesExtra 结构体的 Protocol Buffer 描述符。
func (*MessageBytesExtra) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{2} // 返回原始描述符和字段索引。
}

// GetMessage1 方法返回 MessageBytesExtra 的 Message1 字段的值。
func (x *MessageBytesExtra) GetMessage1() *SubMessage1 {
	if x != nil {
		return x.Message1 // 如果结构体不为空，返回 Message1 的值。
	}
	return nil // 否则返回 nil。
}

// GetMessage2 方法返回 MessageBytesExtra 的 Message2 字段的值。
func (x *MessageBytesExtra) GetMessage2() []*SubMessage2 {
	if x != nil {
		return x.Message2 // 如果结构体不为空，返回 Message2 的值。
	}
	return nil // 否则返回 nil。
}

// File_msg_proto 是 Protocol Buffer 文件的文件描述符。
var File_msg_proto protoreflect.FileDescriptor

// file_msg_proto_rawDesc 存储了原始的 Protocol Buffer 描述符字节。
var file_msg_proto_rawDesc = []byte{
	0x0a, 0x09, 0x6d, 0x73, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x61, 0x70, 0x70,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x22, 0x3d, 0x0a, 0x0b, 0x53, 0x75, 0x62,
	0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x31, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c,
	0x64, 0x31, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31,
	0x12, 0x16, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x32, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x32, 0x22, 0x3d, 0x0a, 0x0b, 0x53, 0x75, 0x62, 0x4d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x32, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64,
	0x31, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x12,
	0x16, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x32, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x32, 0x22, 0x81, 0x01, 0x0a, 0x11, 0x4d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x45, 0x78, 0x74, 0x72, 0x61, 0x12, 0x35, 0x0a,
	0x08, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x31, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x19, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53,
	0x75, 0x62, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x31, 0x52, 0x08, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x31, 0x12, 0x35, 0x0a, 0x08, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x32,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x75, 0x62, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x32, 0x52, 0x08, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x32, 0x42, 0x09, 0x5a, 0x07, 0x2e,
	0x3b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_msg_proto_rawDescOnce sync.Once
	file_msg_proto_rawDescData = file_msg_proto_rawDesc
)

// file_msg_proto_rawDescGZIP 返回经过 GZIP 压缩的原始 Protocol Buffer 描述符字节。
func file_msg_proto_rawDescGZIP() []byte {
	file_msg_proto_rawDescOnce.Do(func() {
		file_msg_proto_rawDescData = protoimpl.X.CompressGZIP(file_msg_proto_rawDescData) // 压缩原始描述符。
	})
	return file_msg_proto_rawDescData // 返回压缩后的数据。
}

// file_msg_proto_msgTypes 存储了 Protocol Buffer 消息类型信息。
var file_msg_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
// file_msg_proto_goTypes 存储了 Protocol Buffer 消息的 Go 类型。
var file_msg_proto_goTypes = []interface{}{
	(*SubMessage1)(nil),       // 0: app.protobuf.SubMessage1
	(*SubMessage2)(nil),       // 1: app.protobuf.SubMessage2
	(*MessageBytesExtra)(nil), // 2: app.protobuf.MessageBytesExtra
}
// file_msg_proto_depIdxs 存储了 Protocol Buffer 消息的依赖索引。
var file_msg_proto_depIdxs = []int32{
	0, // 0: app.protobuf.MessageBytesExtra.message1:type_name -> app.protobuf.SubMessage1
	1, // 1: app.protobuf.MessageBytesExtra.message2:type_name -> app.protobuf.SubMessage2
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

// init 函数在 main 函数之前执行，用于初始化 Protocol Buffer 文件。
func init() { file_msg_proto_init() }
// file_msg_proto_init 函数用于初始化 Protocol Buffer 文件描述符。
func file_msg_proto_init() {
	if File_msg_proto != nil {
		return // 如果已初始化，则直接返回。
	}
	if !protoimpl.UnsafeEnabled { // 如果不使用不安全模式。
		file_msg_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubMessage1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_msg_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubMessage2); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_msg_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MessageBytesExtra); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{ // 构建 Protocol Buffer 类型。
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(), // Go 包路径。
			RawDescriptor: file_msg_proto_rawDesc,        // 原始描述符。
			NumEnums:      0,                             // 枚举数量。
			NumMessages:   3,                             // 消息数量。
			NumExtensions: 0,                             // 扩展数量。
			NumServices:   0,                             // 服务数量。
		},
		GoTypes:           file_msg_proto_goTypes,     // Go 类型。
		DependencyIndexes: file_msg_proto_depIdxs, // 依赖索引。
		MessageInfos:      file_msg_proto_msgTypes,    // 消息信息。
	}.Build()
	File_msg_proto = out.File // 设置文件描述符。
	file_msg_proto_rawDesc = nil // 清空原始描述符。
	file_msg_proto_goTypes = nil // 清空 Go 类型。
	file_msg_proto_depIdxs = nil // 清空依赖索引。
}
